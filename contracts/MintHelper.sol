/**

www.WrappedPlatform.com
                                 ,;¿╓╖╖www╖╓;,
                        -,╓g@╨╜▒░░rⁿ*"""ⁿⁿ**≡░░▒╜MHw┌
                   .─*╖M╜░='"`                    ''^░╙ª╖,
                .*'┌╜░─'           ,▄▄▄▄▄▄▄▄▄▄▄,        `~╙*,
              .░`,           ¿▄@▓█▓▓▓▓▓▓▓▓▓▓███████▄▄,       "".
           ,g╢▓██▌-       ▄▓█▒▓╢▒▓▓▓▓▓▓▓▓▓▓▓▓▓█████████▌ç       ,▄
         ╒╣╣╣▓███▀    .g▓▓▓▒▒▒╣╣╢╢▓▓▓▓▓▓▓▓██▀`      `▀▀███Ç.,.  .╙███.
         ╣Ñ╝"▀██▀   ,║▒▒▒╫░▒▒▒▒▒╢▒╣╢▓▓▓▓▓█▒╖╓..;╖@@▓▓▄p.╙██▄ ░░░░░╜███ç
        '.,¡█▌'`   ║▒░░░"▒░▒▒▒▒▒▒▒╣╢╣▓▓▓╢████▓▒░▒▓██████▄.▀█▄ └░░░└░█▀▀
        â╣▒█▌    .░░└"'` h░░░▒▒▒▒▒╫▒╫╣▓╬▓██████████████████▓█r `*",:╨█.
       ┌╢╢▐█▒╠╫▓▌▌░!=`   µ¡░░░▒▒▒▒▒▒╫╫╣╬▒▓████████████████████µ,─¡└└░▒█.
      .╢▀╫∩█▌▒╢▒███'¿╓,  L"└░░▒▒▒▒▒▒╜╙╙╙└",,,,     ..,╓╖╥╖¡,"╙▀   '¡¡└╢█╓
     ░@▒▒¿└²█▌╙╢▒█▒▌░╢╣r ╘`'"'`   .╓p@▓▓▓▓▓▓@▄;    '╓@╣▓▓▓▓▓▓▓▄,   '▒▒░╨██╖
    ╥╣▒▒▒▒░ ██µ╠▒█▌█└╫▓▒       ,░░▒▒▒╢╢▒▒▒▀▀▀▀▀Ñµ¿░▒▒▒╢╣▓▓╣╣╢╜╜░░'  '▓╣░╙███▄.
   ╔▒╣║▒▒▒░`▐█▌:▒▒██─╣╣▒,   `,¡░░░░░░└`.'"└░░░=. └▒░░░░▄@▀" "└""└":   ║▒~╢████⌐
  \▒╣▓▓▓║▒░⌐▐█▌'▒▒██═░▒░`  `''^─«╘≡═           ``  ▒░▄▓▓∩              ::╘▐█▓█▒
  ║▒╫▒@▓▒▒░`▐█▌'▒╫▌█`└░"       ,╓╗║~               ██▓▓▒L                 ▒█▌█▌
 '▒▒╫▒▄▒▒▒░ ▓█r¡░▓▌█ '``      "╙╝▒▒═               ▓╜╢▒▒░                 Ñ█▌▓█
 ¡▒▒▒▒▒╣╣░`]▓▌,░░▓▐▌     `        ~"          ``  /░m¿.    '........,     ▒█▌▓▌
 └╢▒▒▒▒╣░r,╫▓¡░░╣▒▓      ```      `.```~,,...',⌐ .░░░░░¡.   ,─;;;≈┘"     j▐█▒▓^
  ░╣▒╣▒▒"╓╫Ñ░░░▒╣║`      ````       ```''─"""┐╓▒▓██▄▄▄└"'`    `░┐        ñ▓▓╢Ñ
   ╙▒░░╓║╫░░░░▒▒╠┘       ````              .╓▒╫▓▓▓███████▌@p╖╓╓░▒ç      /╟▓╢╩
    n░╜▓╣▒▒▒▒▒▒╟`        ````........,,;╓░▒▒╢╢▓▓▓▓▓▓█████▓▓▓╣╣╢╢╢╫   `'¡╢╣╜`
  H▒└`'└▓▓╣▒▒@╙          `..',╓╖╖╖µ|░░░░▒▒▒▒▒▒▒╢╢╣╢▓▓▓▓▓▓▓▓╣╣╣▒╣╣╫▓r.╓╨╙`
  ╙'''''''└┘ ,,.        `.:`.░░░░░░░░▒▒ÑÑ╬@▄▄▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▌└
            .▓▒░░~'``````'" '░░MH∩╖┌,,'"²░░░░░░▒▒▒▒▒▀▀▀▀▒▒▒▒▒▒▒╨▒▒
              ╢▒░¡~~'`.````` `"^=»░░░░░░░╜MHHm╥╥▄▄▄▄▄▄▄▄▄▄▄@@@╬╣▒╜
               ╨▒░¡┌~~,,''``````````  .`'"^└░░░░░░░░░░░░░░░░░░╙"
                `╨░░¡~~~~~,,,,,,,,,,,,,,,,,,,,..........,,¡¿"
                ∩░.'"░~~~~~~~~~~~~~~~~~~~:┌┌┌┌┌┌┌┌┌¡¡¡░░┴"
             ╓░┘` '-,    `'''::~~~~~""""""┌¡¡¡░░░░▒▒▓▓▄,
           .░└````...."─=,.           ```        ▒▒▓▓████╖
        .H░┌ ░░¡¡¡¡¡┌┌┌┌¡:¡└└«. .,,,....,,:¿░░░ ~▒╫▓▓██████▌ç
      ┌║░░░░┐]▒▒▒▒▒▒▒░░░░░░░¡¡¡' ┌░░░░░░░░░░░▒▒`▐▓▓▓██████████
    ╓╣▒▒╢╢╢╢▓`▓▓▓▓╣╣▒▒▒▒▒▒▒▒░░░░,`░░░░░░░▒▒▒▒╢╣.▓▓▓██▓▓▓██████▌

  _____       _   _____                  _   _ ______ _______   __  __            _        _         _                
 |  __ \     | | |  __ \                | \ | |  ____|__   __| |  \/  |          | |      | |       | |               
 | |  | |    | | | |__) |__ _ __   ___  |  \| | |__     | |    | \  / | __ _ _ __| | _____| |_ _ __ | | __ _  ___ ___ 
 | |  | |_   | | |  ___/ _ \ '_ \ / _ \ | . ` |  __|    | |    | |\/| |/ _` | '__| |/ / _ \ __| '_ \| |/ _` |/ __/ _ \
 | |__| | |__| | | |  |  __/ |_) |  __/ | |\  | |       | |    | |  | | (_| | |  |   <  __/ |_| |_) | | (_| | (_|  __/
 |_____/ \____/  |_|   \___| .__/ \___| |_| \_|_|       |_|    |_|  |_|\__,_|_|  |_|\_\___|\__| .__/|_|\__,_|\___\___|
                           | |                                                                | |                     
                           |_|                                                                |_|                     
 */

// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC721/IERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/cryptography/ECDSA.sol";

import "./interfaces/IERC721NFT.sol";
import "./interfaces/IMemberPass.sol";
import "./interfaces/IUniswapRouter01.sol";

contract MintHelper is Ownable, ERC721Holder {
    using ECDSA for bytes32;

    address public constant NATIVE_ADDRESS =
        address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);

    uint256 public constant PERCENTS_DIVIDER = 10000;

    address public signerAddress;
    address public feeAddress;

    address public memberpassAddress;
    address public buyTokenAddress = NATIVE_ADDRESS;

    address public swapRouter;
    mapping(address => address[]) public feeSwapPath;

    bool public _bLocked;

    mapping(uint256 => bool) public usedSignature;

    mapping(address => bool) public _managers;
    mapping(address => bool) public _creators;

    uint256[] public mintPrice = new uint256[](5); // mint price[version]
    uint256[] public memberDiscount = new uint256[](5); // discount rate [0, 10%: 1000, 20%:2000, 30%:3000, 40%:4000]

    event ManagerAdded(address manager);
    event ManagerRemoved(address manager);

    event CreatorAdded(address creator);
    event CreatorRemoved(address creator);

    constructor(address _owner) {
        _transferOwnership(_owner);
        feeAddress = _owner;
        signerAddress = _owner;
        _managers[_owner] = true;
        _creators[_owner] = true;
    }

    function addManager(address managerAddress) public onlyOwner {
        require(managerAddress != address(0), "manager: address is zero");
        require(
            _managers[managerAddress] != true,
            "manager: address is already manager"
        );
        _managers[managerAddress] = true;
        emit ManagerAdded(managerAddress);
    }

    function removeManager(address managerAddress) public onlyOwner {
        require(managerAddress != address(0), "manager: address is zero");
        require(
            _managers[managerAddress] != false,
            "manager: address is already not manager"
        );
        _managers[managerAddress] = false;
        emit ManagerRemoved(managerAddress);
    }

    function emergencyWithdrawToken(
        address token_,
        address to_,
        uint256 amount_
    ) public onlyOwner {
        SafeERC20.safeTransfer(IERC20(token_), to_, amount_);
    }

    function emergencyWithdrawCoin(
        address payable to_,
        uint256 amount_
    ) public onlyOwner {
        (bool result, ) = to_.call{value: amount_}("");
        require(result, "withdraw failed");
    }

    function setSignerAddress(address _signerAddress) external onlyOwner {
        require(_signerAddress != address(0), "Invalid address");
        signerAddress = _signerAddress;
    }

    function setMemberPassAddress(address _memberpassAddress) public onlyOwner {
        memberpassAddress = _memberpassAddress;
    }

    function setMemberDiscount(
        uint256[] memory _memberDiscount
    ) external onlyOwner {
        delete memberDiscount;
        uint256 len = _memberDiscount.length;
        for (uint256 i = 0; i < len; i++) {
            memberDiscount.push(_memberDiscount[i]);
        }
    }

    function setFee(
        address _feeAddress,
        address _buyTokenAddress,
        uint256[] memory _mintPrice
    ) external onlyOwner {
        feeAddress = _feeAddress;
        buyTokenAddress = _buyTokenAddress;
        delete mintPrice;
        uint256 len = _mintPrice.length;
        for (uint256 i = 0; i < len; i++) {
            mintPrice.push(_mintPrice[i]);
        }
    }

    function setFeeSwapRouter(address _swapRouter) external onlyOwner {
        swapRouter = _swapRouter;
    }

    function setFeeSwapPath(
        address _tokenAddr,
        address[] calldata _swapPath
    ) external onlyOwner {
        feeSwapPath[_tokenAddr] = _swapPath;
    }

    function addCreator(address creatorAddress) public onlyManager {
        require(creatorAddress != address(0), "creator: address is zero");
        require(
            _creators[creatorAddress] != true,
            "creator: address is already creator"
        );
        _creators[creatorAddress] = true;
        emit CreatorAdded(creatorAddress);
    }

    function removeCreator(address creatorAddress) public onlyManager {
        require(creatorAddress != address(0), "creator: address is zero");
        require(
            _creators[creatorAddress] != false,
            "creator: address is already not creator"
        );
        _creators[creatorAddress] = false;
        emit CreatorRemoved(creatorAddress);
    }

    function swapAndTransfer(
        address _tokenAddr,
        address _to,
        uint256 _amount,
        bool _isEnableSwap
    ) internal {
        bool isNativeCoin = _tokenAddr == NATIVE_ADDRESS;
        if (_amount == 0) return;
        if (_to == address(0)) return;

        IERC20 _mainToken = IERC20(_tokenAddr);
        if (
            swapRouter == address(0) ||
            !_isEnableSwap ||
            feeSwapPath[_tokenAddr][0] == feeSwapPath[_tokenAddr][1]
        ) {
            if (isNativeCoin) {
                (bool result, ) = payable(_to).call{value: _amount}("");
                require(result, "Failed to transfer coin");
            } else {
                SafeERC20.safeTransfer(_mainToken, _to, _amount);
            }
        } else {
            if (isNativeCoin) {
                IUniswapRouter01(swapRouter)
                    .swapExactETHForTokensSupportingFeeOnTransferTokens{
                    value: _amount
                }(0, feeSwapPath[NATIVE_ADDRESS], _to, block.timestamp + 60);
            } else {
                _mainToken.approve(swapRouter, 0);
                _mainToken.approve(swapRouter, _amount);
                IUniswapRouter01(swapRouter)
                    .swapExactTokensForTokensSupportingFeeOnTransferTokens(
                        _amount,
                        0,
                        feeSwapPath[_tokenAddr],
                        _to,
                        block.timestamp + 60
                    );
            }
        }
    }

    function isNativeToken(address _address) public pure returns (bool) {
        return _address == NATIVE_ADDRESS;
    }

    function getMemberLevel(address user) public view returns (uint256) {
        if (memberpassAddress == address(0)) return 0;
        uint256 memberLevel = 0;
        for (uint256 i = 4; i > 0; i--) {
            if (
                IMemberPass(memberpassAddress).memberPassBalanceOf(user, i) > 0
            ) {
                memberLevel = i;
                break;
            }
        }
        return memberLevel;
    }

    function getMintCost(
        address user,
        uint256 version
    ) public view returns (uint256 _cost) {
        if (memberpassAddress == address(0)) return mintPrice[version];
        _cost = mintPrice[version];
        uint256 memberLevel = getMemberLevel(user);
        _cost =
            _cost -
            (_cost * memberDiscount[memberLevel]) /
            PERCENTS_DIVIDER;
    }

    function processCost(
        address _user,
        uint256 _txValue,
        uint256 _mintCost
    ) internal {
        if (isNativeToken(buyTokenAddress)) {
            if (_txValue < _mintCost) {
                revert("NFT: Insufficient mint fees!");
            } else if (_txValue > _mintCost) {
                payable(_user).transfer(_txValue - _mintCost);
            }
        } else {
            if (_txValue > 0) {
                payable(_user).transfer(_txValue);
            }
            SafeERC20.safeTransferFrom(
                IERC20(buyTokenAddress),
                _user,
                address(this),
                _mintCost
            );
        }
        swapAndTransfer(buyTokenAddress, feeAddress, _mintCost, true);
    }

    function addItem(
        address _collectionAddr,
        string memory _tokenURI,
        uint256 royalty,
        uint256 mintVersion
    ) external payable onlyCreator {
        uint256 mintCost = getMintCost(msg.sender, mintVersion);
        processCost(msg.sender, msg.value, mintCost);
        IERC721NFT(_collectionAddr).addItem(msg.sender, _tokenURI, royalty);
    }

    function addItemBulk(
        address _collectionAddr,
        string[] memory _tokenURIs,
        uint256 royalty,
        uint256 mintVersion
    ) external payable onlyCreator {
        uint256 mintAmount = _tokenURIs.length;
        uint256 mintCost = getMintCost(msg.sender, mintVersion);
        processCost(msg.sender, msg.value, mintCost * mintAmount);
        IERC721NFT(_collectionAddr).addItemBulk(
            msg.sender,
            _tokenURIs,
            royalty
        );
    }

    function checkSignature(
        address executor,
        uint256 uniqueId,
        uint256 expireTime,
        string memory functionName,
        bytes memory signature
    ) internal {
        require(usedSignature[uniqueId] == false, "Used signature");
        usedSignature[uniqueId] = true;

        require(block.timestamp < expireTime, "Expired signature");
        uint256 chainId;
        assembly {
            chainId := chainid()
        }
        require(
            keccak256(
                abi.encodePacked(
                    this,
                    chainId,
                    functionName,
                    executor,
                    uniqueId,
                    expireTime
                )
            ).toEthSignedMessageHash().recover(signature) == signerAddress,
            "Invalid signature"
        );
    }

    modifier onlyManager() {
        require(_managers[msg.sender] == true, "caller is not the manager");
        _;
    }

    modifier onlyCreator() {
        require(_creators[msg.sender] == true, "caller is not the creator");
        _;
    }

    modifier onlyTokenOwner(address _collectionId, uint256 _tokenId) {
        address tokenOwner = IERC721(_collectionId).ownerOf(_tokenId);
        require(tokenOwner == msg.sender);
        _;
    }

    modifier reentrancyGuard() {
        require(!_bLocked, "Execution locked");
        _bLocked = true;
        _;
        _bLocked = false;
    }
}
