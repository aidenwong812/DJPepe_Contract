/**

www.WrappedPlatform.com
                                 ,;¿╓╖╖www╖╓;,
                        -,╓g@╨╜▒░░rⁿ*"""ⁿⁿ**≡░░▒╜MHw┌
                   .─*╖M╜░='"`                    ''^░╙ª╖,
                .*'┌╜░─'           ,▄▄▄▄▄▄▄▄▄▄▄,        `~╙*,
              .░`,           ¿▄@▓█▓▓▓▓▓▓▓▓▓▓███████▄▄,       "".
           ,g╢▓██▌-       ▄▓█▒▓╢▒▓▓▓▓▓▓▓▓▓▓▓▓▓█████████▌ç       ,▄
         ╒╣╣╣▓███▀    .g▓▓▓▒▒▒╣╣╢╢▓▓▓▓▓▓▓▓██▀`      `▀▀███Ç.,.  .╙███.
         ╣Ñ╝"▀██▀   ,║▒▒▒╫░▒▒▒▒▒╢▒╣╢▓▓▓▓▓█▒╖╓..;╖@@▓▓▄p.╙██▄ ░░░░░╜███ç
        '.,¡█▌'`   ║▒░░░"▒░▒▒▒▒▒▒▒╣╢╣▓▓▓╢████▓▒░▒▓██████▄.▀█▄ └░░░└░█▀▀
        â╣▒█▌    .░░└"'` h░░░▒▒▒▒▒╫▒╫╣▓╬▓██████████████████▓█r `*",:╨█.
       ┌╢╢▐█▒╠╫▓▌▌░!=`   µ¡░░░▒▒▒▒▒▒╫╫╣╬▒▓████████████████████µ,─¡└└░▒█.
      .╢▀╫∩█▌▒╢▒███'¿╓,  L"└░░▒▒▒▒▒▒╜╙╙╙└",,,,     ..,╓╖╥╖¡,"╙▀   '¡¡└╢█╓
     ░@▒▒¿└²█▌╙╢▒█▒▌░╢╣r ╘`'"'`   .╓p@▓▓▓▓▓▓@▄;    '╓@╣▓▓▓▓▓▓▓▄,   '▒▒░╨██╖
    ╥╣▒▒▒▒░ ██µ╠▒█▌█└╫▓▒       ,░░▒▒▒╢╢▒▒▒▀▀▀▀▀Ñµ¿░▒▒▒╢╣▓▓╣╣╢╜╜░░'  '▓╣░╙███▄.
   ╔▒╣║▒▒▒░`▐█▌:▒▒██─╣╣▒,   `,¡░░░░░░└`.'"└░░░=. └▒░░░░▄@▀" "└""└":   ║▒~╢████⌐
  \▒╣▓▓▓║▒░⌐▐█▌'▒▒██═░▒░`  `''^─«╘≡═           ``  ▒░▄▓▓∩              ::╘▐█▓█▒
  ║▒╫▒@▓▒▒░`▐█▌'▒╫▌█`└░"       ,╓╗║~               ██▓▓▒L                 ▒█▌█▌
 '▒▒╫▒▄▒▒▒░ ▓█r¡░▓▌█ '``      "╙╝▒▒═               ▓╜╢▒▒░                 Ñ█▌▓█
 ¡▒▒▒▒▒╣╣░`]▓▌,░░▓▐▌     `        ~"          ``  /░m¿.    '........,     ▒█▌▓▌
 └╢▒▒▒▒╣░r,╫▓¡░░╣▒▓      ```      `.```~,,...',⌐ .░░░░░¡.   ,─;;;≈┘"     j▐█▒▓^
  ░╣▒╣▒▒"╓╫Ñ░░░▒╣║`      ````       ```''─"""┐╓▒▓██▄▄▄└"'`    `░┐        ñ▓▓╢Ñ
   ╙▒░░╓║╫░░░░▒▒╠┘       ````              .╓▒╫▓▓▓███████▌@p╖╓╓░▒ç      /╟▓╢╩
    n░╜▓╣▒▒▒▒▒▒╟`        ````........,,;╓░▒▒╢╢▓▓▓▓▓▓█████▓▓▓╣╣╢╢╢╫   `'¡╢╣╜`
  H▒└`'└▓▓╣▒▒@╙          `..',╓╖╖╖µ|░░░░▒▒▒▒▒▒▒╢╢╣╢▓▓▓▓▓▓▓▓╣╣╣▒╣╣╫▓r.╓╨╙`
  ╙'''''''└┘ ,,.        `.:`.░░░░░░░░▒▒ÑÑ╬@▄▄▄▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒▓▓▓▓▌└
            .▓▒░░~'``````'" '░░MH∩╖┌,,'"²░░░░░░▒▒▒▒▒▀▀▀▀▒▒▒▒▒▒▒╨▒▒
              ╢▒░¡~~'`.````` `"^=»░░░░░░░╜MHHm╥╥▄▄▄▄▄▄▄▄▄▄▄@@@╬╣▒╜
               ╨▒░¡┌~~,,''``````````  .`'"^└░░░░░░░░░░░░░░░░░░╙"
                `╨░░¡~~~~~,,,,,,,,,,,,,,,,,,,,..........,,¡¿"
                ∩░.'"░~~~~~~~~~~~~~~~~~~~:┌┌┌┌┌┌┌┌┌¡¡¡░░┴"
             ╓░┘` '-,    `'''::~~~~~""""""┌¡¡¡░░░░▒▒▓▓▄,
           .░└````...."─=,.           ```        ▒▒▓▓████╖
        .H░┌ ░░¡¡¡¡¡┌┌┌┌¡:¡└└«. .,,,....,,:¿░░░ ~▒╫▓▓██████▌ç
      ┌║░░░░┐]▒▒▒▒▒▒▒░░░░░░░¡¡¡' ┌░░░░░░░░░░░▒▒`▐▓▓▓██████████
    ╓╣▒▒╢╢╢╢▓`▓▓▓▓╣╣▒▒▒▒▒▒▒▒░░░░,`░░░░░░░▒▒▒▒╢╣.▓▓▓██▓▓▓██████▌

  _____       _   _____                  _   _ ______ _______   __  __            _        _         _                
 |  __ \     | | |  __ \                | \ | |  ____|__   __| |  \/  |          | |      | |       | |               
 | |  | |    | | | |__) |__ _ __   ___  |  \| | |__     | |    | \  / | __ _ _ __| | _____| |_ _ __ | | __ _  ___ ___ 
 | |  | |_   | | |  ___/ _ \ '_ \ / _ \ | . ` |  __|    | |    | |\/| |/ _` | '__| |/ / _ \ __| '_ \| |/ _` |/ __/ _ \
 | |__| | |__| | | |  |  __/ |_) |  __/ | |\  | |       | |    | |  | | (_| | |  |   <  __/ |_| |_) | | (_| | (_|  __/
 |_____/ \____/  |_|   \___| .__/ \___| |_| \_|_|       |_|    |_|  |_|\__,_|_|  |_|\_\___|\__| .__/|_|\__,_|\___\___|
                           | |                                                                | |                     
                           |_|                                                                |_|                     
 */
// SPDX-License-Identifier: MIT
//

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";

import "./interfaces/IERC721NFT.sol";
import "./interfaces/IRoyaltyRegistry.sol";
import "./interfaces/IMemberPass.sol";
import "./interfaces/IUniswapRouter01.sol";

contract NFTMarket is Ownable, ERC721Holder {
    address public constant NATIVE_ADDRESS =
        address(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);

    uint256 public constant PERCENTS_DIVIDER = 10000;

    uint256 public feePercent = 500;
    address public feeAddress;

    uint256 public listingFee = 100 ether;
    address public swapRouter;
    mapping(address => address[]) public feeSwapPath;

    address public royaltyRegistry;
    address public signerAddress;

    address public memberpassAddress;
    uint256[] public memberDiscount = new uint256[](5); // discount rate [0%:0, 10%: 1000, 20%:2000, 30%:3000, 40%:4000]

    mapping(address => bool) public _managers;

    bool public _bLocked;

    struct Splits {
        address receiver;
        uint256 commission;
    }

    /* Pairs to swap NFT _id => price */
    struct Pair {
        uint256 pair_id;
        address collectionAddr;
        uint256 token_id;
        address creator;
        address owner;
        address buyTokenAddr;
        uint256 price;
        uint256 creatorFee;
        Splits[] splits;
        bool isSell;
        bool bValid;
    }

    // token id => Pair mapping
    mapping(uint256 => Pair) public pairs;
    uint256 public currentPairId;

    mapping(address => uint256) public totalEarnings;
    uint256 public totalSwapped; /* Total swap count */

    /** Events */
    event ManagerAdded(address manager);
    event ManagerRemoved(address manager);

    event ItemListed(Pair pair);
    event ItemDelisted(uint256 id);
    event Swapped(address buyer, Pair pair);

    constructor(address _owner, address _royaltyRegistry) {
        _transferOwnership(_owner);
        feeAddress = _owner;
        royaltyRegistry = _royaltyRegistry;
    }

    function addManager(address managerAddress) public onlyOwner {
        require(managerAddress != address(0), "manager: address is zero");
        require(
            _managers[managerAddress] != true,
            "manager: address is already manager"
        );
        _managers[managerAddress] = true;
        emit ManagerAdded(managerAddress);
    }

    function removeManager(address managerAddress) public onlyOwner {
        require(managerAddress != address(0), "manager: address is zero");
        require(
            _managers[managerAddress] != false,
            "manager: address is already not manager"
        );
        _managers[managerAddress] = false;
        emit ManagerRemoved(managerAddress);
    }

    function emergencyWithdrawToken(
        address token_,
        address to_,
        uint256 amount_
    ) public onlyOwner {
        SafeERC20.safeTransfer(IERC20(token_), to_, amount_);
    }

    function emergencyWithdrawCoin(
        address payable to_,
        uint256 amount_
    ) public onlyOwner {
        (bool result, ) = to_.call{value: amount_}("");
        require(result, "withdraw failed");
    }

    function setMemberPassAddress(address _memberpassAddress) public onlyOwner {
        memberpassAddress = _memberpassAddress;
    }

    function setMemberDiscount(
        uint256[] memory _memberDiscount
    ) external onlyOwner {
        delete memberDiscount;
        uint256 len = _memberDiscount.length;
        for (uint256 i = 0; i < len; i++) {
            memberDiscount.push(_memberDiscount[i]);
        }
    }

    function setFee(
        address _feeAddress,
        uint256 _adminFee,
        uint256 _listingFee
    ) external onlyOwner {
        feePercent = _adminFee;
        feeAddress = _feeAddress;
        listingFee = _listingFee;
    }

    function setFeeSwapRouter(address _swapRouter) external onlyOwner {
        swapRouter = _swapRouter;
    }

    function setFeeSwapPath(
        address _tokenAddr,
        address[] calldata _swapPath
    ) external onlyOwner {
        feeSwapPath[_tokenAddr] = _swapPath;
    }

    function setSignerAddress(address _signerAddress) external onlyOwner {
        require(_signerAddress != address(0), "Invalid address");
        signerAddress = _signerAddress;
    }

    function setRoyaltyRegistry(address _royaltyRegistry) external onlyOwner {
        require(_royaltyRegistry != address(0), "Invalid address");
        royaltyRegistry = _royaltyRegistry;
    }

    function swapAndTransfer(
        address _tokenAddr,
        address _to,
        uint256 _amount,
        bool _isEnableSwap
    ) internal {
        bool isNativeCoin = _tokenAddr == NATIVE_ADDRESS;
        if (_amount == 0) return;
        if (_to == address(0)) return;

        IERC20 _mainToken = IERC20(_tokenAddr);
        if (
            swapRouter == address(0) ||
            !_isEnableSwap ||
            feeSwapPath[_tokenAddr][0] == feeSwapPath[_tokenAddr][1]
        ) {
            if (isNativeCoin) {
                (bool result, ) = payable(_to).call{value: _amount}("");
                require(result, "Failed to transfer coin");
            } else {
                SafeERC20.safeTransfer(_mainToken, _to, _amount);
            }
        } else {
            if (isNativeCoin) {
                IUniswapRouter01(swapRouter)
                    .swapExactETHForTokensSupportingFeeOnTransferTokens{
                    value: _amount
                }(0, feeSwapPath[NATIVE_ADDRESS], _to, block.timestamp + 60);
            } else {
                _mainToken.approve(swapRouter, 0);
                _mainToken.approve(swapRouter, _amount);
                IUniswapRouter01(swapRouter)
                    .swapExactTokensForTokensSupportingFeeOnTransferTokens(
                        _amount,
                        0,
                        feeSwapPath[_tokenAddr],
                        _to,
                        block.timestamp + 60
                    );
            }
        }
    }

    function list(
        address _collectionAddr,
        uint256 _token_id,
        uint256 _price,
        address _buyTokenAddr,
        Splits[] memory splits
    ) public payable OnlyItemOwner(_collectionAddr, _token_id) ReentrancyGuard {
        require(_price > 0, "Invalid price");
        require(msg.value >= listingFee, "Insufficient listing fee");

        IERC721NFT(_collectionAddr).safeTransferFrom(
            msg.sender,
            address(this),
            _token_id
        );

        swapAndTransfer(NATIVE_ADDRESS, feeAddress, msg.value, true);

        currentPairId = currentPairId + 1;

        Pair storage pair = pairs[currentPairId];
        pair.pair_id = currentPairId;
        pair.collectionAddr = _collectionAddr;
        pair.token_id = _token_id;
        pair.creator = IRoyaltyRegistry(royaltyRegistry).getCreator(
            _collectionAddr,
            _token_id
        );
        pair.creatorFee = IRoyaltyRegistry(royaltyRegistry).getRoyalty(
            _collectionAddr,
            _token_id
        );
        pair.owner = msg.sender;
        pair.price = _price;
        pair.buyTokenAddr = _buyTokenAddr;
        pair.splits = splits;
        pair.isSell = true;
        pair.bValid = true;

        emit ItemListed(pair);
    }

    function delist(uint256 _id) external ItemExists(_id) ReentrancyGuard {
        Pair storage pair = pairs[_id];
        require(pair.bValid, "Invalid pair");
        require(
            msg.sender == pair.owner || msg.sender == owner(),
            "Error, you are not the owner"
        );
        require(pair.isSell, "Wrong function call");
        IERC721NFT(pair.collectionAddr).safeTransferFrom(
            address(this),
            pair.owner,
            pair.token_id
        );
        pair.bValid = false;
        emit ItemDelisted(_id);
    }

    function buy(uint256 _id) external payable ItemExists(_id) ReentrancyGuard {
        Pair memory pair = pairs[_id];
        require(pair.bValid, "Invalid pair");
        require(pair.owner != msg.sender, "Owner can not buy");
        require(pair.isSell, "Wrong function call");

        uint256 nftPrice = pair.price;
        address buyTokenAddr = pair.buyTokenAddr;
        bool isNativeCoin = buyTokenAddr == NATIVE_ADDRESS;
        Splits[] memory splits = pair.splits;

        uint256 total_balance = isNativeCoin
            ? msg.value
            : IERC20(buyTokenAddr).balanceOf(msg.sender);

        require(total_balance >= nftPrice, "Insufficient balance");

        uint256 _memberFee = 0;
        if (_managers[pair.owner] == true) {
            uint256 _memberLevel = getMemberLevel(msg.sender);
            _memberFee =
                (nftPrice * memberDiscount[_memberLevel]) /
                PERCENTS_DIVIDER;
        }

        uint256 _adminFee = (nftPrice * feePercent) / PERCENTS_DIVIDER;
        uint256 _creatorFee = (nftPrice * pair.creatorFee) / PERCENTS_DIVIDER;
        uint256 _sellerFee = nftPrice - _adminFee - _creatorFee - _memberFee;

        if (!isNativeCoin) {
            require(msg.value == 0, "Invalid payable amount");
            IERC20 buyToken = IERC20(buyTokenAddr);

            SafeERC20.safeTransferFrom(
                buyToken,
                msg.sender,
                address(this),
                nftPrice
            );
        }
        swapAndTransfer(buyTokenAddr, feeAddress, _adminFee, true);
        swapAndTransfer(buyTokenAddr, msg.sender, _memberFee, false);
        swapAndTransfer(buyTokenAddr, pair.creator, _creatorFee, false);

        if (_sellerFee > 0) {
            uint256 splitsLen = splits.length;
            uint256 lastSplit = _sellerFee;
            for (uint256 i = 0; i < splitsLen; i++) {
                uint256 _splitSend = (_sellerFee * splits[i].commission) /
                    PERCENTS_DIVIDER;
                if (i == splitsLen - 1) _splitSend = lastSplit;
                else lastSplit = lastSplit - _splitSend;
                swapAndTransfer(
                    buyTokenAddr,
                    splits[i].receiver,
                    _splitSend,
                    false
                );
            }
        }

        // transfer NFT token to buyer
        IERC721NFT(pair.collectionAddr).safeTransferFrom(
            address(this),
            msg.sender,
            pair.token_id
        );

        pairs[_id].bValid = false;

        totalEarnings[buyTokenAddr] = totalEarnings[buyTokenAddr] + nftPrice;
        totalSwapped = totalSwapped + 1;

        emit Swapped(msg.sender, pair);
    }

    function offer(
        address _collectionAddr,
        uint256 _token_id,
        uint256 _price,
        address _buyTokenAddr
    ) public payable ReentrancyGuard {
        require(_price > 0, "Invalid price");

        bool isNativeCoin = _buyTokenAddr == NATIVE_ADDRESS;
        if (isNativeCoin) {
            require(msg.value >= _price, "Insufficient amount");
        } else {
            require(msg.value == 0, "Invalid payable amount");
            SafeERC20.safeTransferFrom(
                IERC20(_buyTokenAddr),
                msg.sender,
                address(this),
                _price
            );
        }

        currentPairId = currentPairId + 1;

        Pair storage pair = pairs[currentPairId];
        pair.pair_id = currentPairId;
        pair.collectionAddr = _collectionAddr;
        pair.token_id = _token_id;
        pair.creator = IRoyaltyRegistry(royaltyRegistry).getCreator(
            _collectionAddr,
            _token_id
        );
        pair.creatorFee = IRoyaltyRegistry(royaltyRegistry).getRoyalty(
            _collectionAddr,
            _token_id
        );
        pair.owner = msg.sender;
        pair.price = _price;
        pair.buyTokenAddr = _buyTokenAddr;
        pair.isSell = false;
        pair.bValid = true;

        emit ItemListed(pair);
    }

    function cancelOffer(uint256 _id) external ItemExists(_id) ReentrancyGuard {
        Pair memory pair = pairs[_id];
        require(pair.bValid, "Invalid pair");
        require(!pair.isSell, "Wrong function call");
        require(
            msg.sender == pair.owner || msg.sender == owner(),
            "Error, you are not the owner"
        );
        swapAndTransfer(pair.buyTokenAddr, pair.owner, pair.price, false);
        pairs[_id].bValid = false;
        emit ItemDelisted(_id);
    }

    function sell(
        uint256 _id,
        Splits[] memory splits
    )
        external
        payable
        ItemExists(_id)
        OnlyItemOwner(pairs[_id].collectionAddr, pairs[_id].token_id)
        ReentrancyGuard
    {
        Pair memory pair = pairs[_id];
        require(pair.bValid, "Invalid Pair");
        require(!pair.isSell, "Wrong function call");
        require(pair.owner != msg.sender, "Owner can not sell");

        uint256 nftPrice = pair.price;
        address buyTokenAddr = pair.buyTokenAddr;

        uint256 _memberFee = 0;
        if (_managers[msg.sender] == true) {
            uint256 _memberLevel = getMemberLevel(pair.owner);
            _memberFee =
                (nftPrice * memberDiscount[_memberLevel]) /
                PERCENTS_DIVIDER;
        }
        uint256 _adminFee = (nftPrice * feePercent) / PERCENTS_DIVIDER;
        uint256 _creatorFee = (nftPrice * pair.creatorFee) / PERCENTS_DIVIDER;
        uint256 _sellerFee = nftPrice - _adminFee - _creatorFee - _memberFee;

        swapAndTransfer(buyTokenAddr, feeAddress, _adminFee, true);
        swapAndTransfer(buyTokenAddr, pair.owner, _memberFee, false);
        swapAndTransfer(buyTokenAddr, pair.creator, _creatorFee, false);

        if (_sellerFee > 0) {
            uint256 splitsLen = splits.length;
            uint256 lastSplit = _sellerFee;
            for (uint256 i = 0; i < splitsLen; i++) {
                uint256 _splitSend = (_sellerFee * splits[i].commission) /
                    PERCENTS_DIVIDER;
                if (i == splitsLen - 1) _splitSend = lastSplit;
                else lastSplit = lastSplit - _splitSend;
                swapAndTransfer(
                    buyTokenAddr,
                    splits[i].receiver,
                    _splitSend,
                    false
                );
            }
        }

        // transfer NFT token to buyer
        IERC721NFT(pair.collectionAddr).safeTransferFrom(
            msg.sender,
            pair.owner,
            pair.token_id
        );

        pairs[_id].splits = splits;
        pairs[_id].bValid = false;

        totalEarnings[buyTokenAddr] = totalEarnings[buyTokenAddr] + nftPrice;
        totalSwapped = totalSwapped + 1;

        emit Swapped(msg.sender, pair);
    }

    function getMemberLevel(address user) public view returns (uint256) {
        if (memberpassAddress == address(0)) return 0;
        uint256 memberLevel = 0;
        for (uint256 i = 4; i > 0; i--) {
            if (
                IMemberPass(memberpassAddress).memberPassBalanceOf(user, i) > 0
            ) {
                memberLevel = i;
                break;
            }
        }
        return memberLevel;
    }

    modifier OnlyItemOwner(address collectionAddr, uint256 tokenId) {
        require(IERC721NFT(collectionAddr).ownerOf(tokenId) == msg.sender);
        _;
    }

    modifier ItemExists(uint256 id) {
        require(
            id <= currentPairId && pairs[id].pair_id == id,
            "Could not find item"
        );
        _;
    }

    modifier ReentrancyGuard() {
        require(!_bLocked, "Execution locked");
        _bLocked = true;
        _;
        _bLocked = false;
    }
}
